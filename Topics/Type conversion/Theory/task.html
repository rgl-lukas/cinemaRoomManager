<div class="step-text">
<p>Type conversion, or type casting, involves switching a value from one <a class="theory-lookup not-relevant" href="/learn/step/4672" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a data type is a classification that specifies the kind of value that a variable, expression, or function parameter can hold. | It is an essential aspect of a statically-typed language like Kotlin, which requires explicit or implicit type declarations for variables and function parameters. For instance, Kotlin has various data types, such as integers, floating-point numbers, characters, booleans, and strings. Among these, strings are a widely-used data type that represents a sequence of zero or more characters enclosed by double quotes. Strings are often used in conditional statements and regular expressions, and they have various operations, such as getting the length or concatenating two strings. Moreover, type inference is a helpful feature in Kotlin that allows the compiler to deduce the data type of a variable, expression, or function parameter automatically, making the code more concise and readable.">data type</a> to another. This is notably critical in Kotlin because it is a statically typed language, which signifies that types are identified and strictly applied at compile time.</p>
<h5 id="implicit-conversion">Implicit Conversion</h5>
<p>Kotlin does not permit implicit conversions to avoid precision loss or unforeseen outcomes. For instance, a <code class="language-kotlin">Long</code> cannot automatically convert to an <code class="language-kotlin">Int</code>.</p>
<pre><code class="language-kotlin">val longValue: Long = 100L
// val intValue: Int = longValue // Error: Type mismatch
</code></pre>
<h5 id="explicit-type-conversion-type-casts-in-kotlin">Explicit Type Conversion (Type Casts) in Kotlin</h5>
<p>When you need to switch a variable from one type to another in Kotlin, <a class="theory-lookup not-relevant" href="/learn/step/4672" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, explicit type conversion, also known as type casting, is the process of changing a value from one data type to another. | This is particularly important in Kotlin because it is a statically typed language, which means that types are identified and strictly applied at compile time. Kotlin does not allow implicit conversion to avoid precision loss or unforeseen outcomes. When you need to change a variable from one type to another in Kotlin, explicit type conversion is necessary. This is because Kotlin is a statically-typed language, meaning type are checked at compile time and implicit type conversion is not permitted.">explicit type conversion</a> is necessary. Kotlin is a statically-typed language, meaning types are checked at compile time and implicit type conversion is not permitted. Below are some methods that Kotlin provides for explicit type conversion:</p>
<ul><li><p><code class="language-kotlin">toInt()</code>: Use this when you need to transform the value into an <code class="language-kotlin">Int</code>, or an integer format of a value.</p><pre><code class="language-kotlin">val doubleValue = 2.5
val intValue = doubleValue.toInt() // intValue will be 2</code></pre></li><li><p><code class="language-kotlin">toFloat()</code>: Converts the value to a floating-point representation, or <code class="language-kotlin">Float</code>.</p><pre><code class="language-kotlin">val intValue = 10
val floatValue = intValue.toFloat() // floatValue will be 10.0</code></pre></li><li><p><code class="language-kotlin">toLong()</code>: Use this when working with larger integer values; it transforms the value into a <code class="language-kotlin">Long</code>.</p><pre><code class="language-kotlin">val intValue = 100
val longValue = intValue.toLong() // longValue will be 100L</code></pre></li><li><p><code class="language-kotlin">toDouble()</code>: Use this when dealing with high-precision arithmetic, it transforms the value into a <code class="language-kotlin">Double</code>.</p><pre><code class="language-kotlin">val floatValue = 10.5f
val doubleValue = floatValue.toDouble() // doubleValue will be 10.5</code></pre></li><li><p><code class="language-kotlin">toByte()</code>: Transforms the value into a <code class="language-kotlin">Byte</code>; it's often used when dealing with low-level byte manipulation.</p><pre><code class="language-kotlin">val intValue = 1
val byteValue = intValue.toByte() // byteValue will be 1</code></pre></li><li><p><code class="language-kotlin">toShort()</code>: Transforms the value into a <code class="language-kotlin">Short</code>. This method is lesser-known but can be helpful for specific scenarios.</p><pre><code class="language-kotlin">val intValue = 5
val shortValue = intValue.toShort() // shortValue will be 5</code></pre></li><li><p><code class="language-kotlin">toString()</code>: This is often used for converting the value into a text representation, <code class="language-kotlin">String</code>, or for <a class="theory-lookup not-relevant" href="/learn/step/4672" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, concatenation refers to the process of combining two or more strings into a single string. | This is a common operation when working with strings and is often used to build larger strings from smaller ones. The concatenation operator in Kotlin is the `+` symbol, which can be used to combine any two strings. When concatenating strings, the order of the strings matters, and the resulting string will be in the same order as they are arranged. Concatenation is not the same as addition, because it is not a commutative operation. The `+` operator can also be used to append values of different types to a string. In this case, the value is automatically converted to a string and then concatenated to the target. An expression must start with a string, and if it starts with a different type, it will be converted to a string using the `toString()` function. There are two main ways to construct a string object in Kotlin: using the constructor or using the `StringBuffer` class and its `append()` method. When using the `+` operator, new memory is allocated to store the combined string. However, when using the `StringBuffer` class and its `append()` method, no new memory is allocated.">concatenation</a>.</p><pre><code class="language-kotlin">val intValue = 10
val stringValue = intValue.toString() // stringValue will be "10"</code></pre></li></ul>
<p>Any of these methods can be invoked on a variable to convert it to the desired type. Keep in mind that, if the value being transformed is beyond the range of the target type, data loss or truncation may result. Make sure the value can safely change to prevent unexpected behavior.</p>
<h5 id="type-conversion-best-practices-in-kotlin">Type Conversion Best Practices in Kotlin</h5>
<p>You must execute type conversion with caution in Kotlin to avoid problems like precision loss or <code class="language-kotlin">ClassCastException</code>. Here are some guidelines to remember:</p>
<ol><li><p><strong>Use Explicit Conversions</strong>: Kotlin doesn't permit implicit type conversion, so utilize explicit methods like <code class="language-kotlin">toInt()</code>, <code class="language-kotlin">toDouble()</code>, and so on.</p><pre><code class="language-kotlin">val i: Int = "123".toInt()</code></pre></li><li><p><strong>Check for null</strong>: If you are working with <a class="theory-lookup not-relevant" href="/learn/step/4672" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, a nullable type is a variable that can hold a null value, in contrast to a non-nullable type, which cannot. | This is a key feature of Kotlin's null safety, which aims to eliminate null reference errors. In Kotlin, types are non-nullable by default, and if you want to declare a variable that can hold a null value, you must append a question mark to the type. When working with nullable types, Kotlin requires you to handle the possibility of a null value explicitly, making your code safer and more predictable.">nullable types</a>, make sure to use the safe call operator <code class="language-kotlin">?.</code> before conversion.</p><pre><code class="language-kotlin">val s: String? = null
val i: Int? = s?.toInt()</code></pre></li><li><p><strong>Handle </strong><code class="language-kotlin">NumberFormatException</code>: Potential <code class="language-kotlin">NumberFormatException</code> should be handled when converting from <code class="language-kotlin">String</code> to a numeric type.</p><pre><code class="language-kotlin">val s: String = "abc"
val i: Int? = try { s.toInt() } catch (e: NumberFormatException) { null }</code></pre></li><li><p><strong>Avoid Loss of Precision</strong>: Be careful when converting between numeric types to avoid losing precision.</p><pre><code class="language-kotlin">val l: Long = 1_000_000_000L
val i: Int = l.toInt() // Potential loss of precision</code></pre></li><li><p><strong>Smart Casts with </strong><code class="language-kotlin">is</code>: Use <code class="language-kotlin">is</code> checks for <a class="theory-lookup not-relevant" href="/learn/step/4672" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, safe casting is the process of converting an object of a certain type to another type in a type-safe manner. | This is achieved through the use of smart casts, which automatically cast a nullable type to a non-nullable type when it has been checked with the `is` or `!is` operator. This eliminates the need for explicit type cast operators and ensures that a `ClassCastException` is not thrown at runtime. Kotlin also provides an unsafe cast operator, represented by the `as?` keyword, which can be used to cast an object to a non-nullable type. However, if the object cannot be cast to the specified type, a `ClassCastException` will be thrown.">safe casting</a> when dealing with inheritance.</p><pre><code class="language-kotlin">if (obj is String) {
    println(obj.length)
}</code></pre></li><li><p><strong>Use the </strong><code class="language-kotlin">as?</code> Operator for Safe Casting: Use <code class="language-kotlin">as?</code> to safely cast to a type and to avoid <code class="language-kotlin">ClassCastException</code>. This will return <code class="language-kotlin">null</code> if the operation fails.</p><pre><code class="language-kotlin">val x: Any = "Kotlin"
val s: String? = x as? String</code></pre></li></ol>
<p>By following these practices, you can ensure that your data remains intact and prevents runtime exceptions during type conversions in Kotlin.</p>
<h5 id="conclusion">Conclusion</h5>
<p>Because of Kotlin's statically typed nature, type conversion is a fundamental concept that demands explicit handling of data type changes. Kotlin does not allow implicit conversions, thereby ensuring <a class="theory-lookup not-relevant" href="/learn/step/4672" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, type safety is a feature of the type system that ensures type compatibility and prevents operations that could cause runtime errors. | It is enforced at compile-time, meaning that any type-related errors will be caught before the code is executed. This is in contrast to dynamically typed languages, where type errors may only be discovered at runtime. In Kotlin, type safety is closely related to null safety, as the type system aims to prevent null reference exceptions. By making types non-nullable by default and requiring explicit nullability annotations, Kotlin helps developers avoid common bugs that result from null reference errors. Additionally, Kotlin's type system offers several mechanisms to handle nullable types securely, such as safe calls and the Elvis operator, which allow for null-checks and default values to be specified in a concise and type-safe way.">type safety</a> and preventing undesirable outcomes. Instead, <a class="theory-lookup not-relevant" href="/learn/step/4672" rel="noopener noreferrer nofollow" target="_blank" title="In Kotlin, explicit conversion, also known as type conversion or type casting, is the process of changing a value from one data type to another. | This is particularly important in Kotlin because it is a statically typed language, which means that type checking is done at compile time and types are strictly applied. Unlike some other languages, Kotlin does not allow implicit conversion to prevent precision loss or unexpected results. When you need to change a variable from one type to another in Kotlin, you must use explicit conversion. This is necessary because Kotlin's statically typed nature means that type conversion is a fundamental concept that requires explicit handling of data type changes. Kotlin does not allow implicit conversion, which ensures type safety and prevents undesirable outcomes.">explicit conversions</a> using methods like <code class="language-kotlin">toInt()</code>, <code class="language-kotlin">toFloat()</code>, and others are necessary when dealing with various numeric types.</p>
</div>